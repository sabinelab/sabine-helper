generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URI")
}

model User {
  id                       String        @id
  created_at               DateTime      @default(now())
  predictions              Prediction[]
  correct_predictions      Int           @default(0) @db.SmallInt
  incorrect_predictions    Int           @default(0) @db.SmallInt
  lang                     Language      @default(en)
  premium                  Premium?
  active_players           String[]
  reserve_players          String[]
  coins                    BigInt        @default(0)
  team_name                String?       @db.VarChar(20)
  team_tag                 String?       @db.VarChar(4)
  arena_wins               Int           @default(0) @db.SmallInt
  ranked_wins              Int           @default(0) @db.SmallInt
  unranked_wins            Int           @default(0) @db.SmallInt
  swiftplay_wins           Int           @default(0) @db.SmallInt
  ranked_swiftplay_wins    Int           @default(0) @db.SmallInt
  arena_defeats            Int           @default(0) @db.SmallInt
  ranked_defeats           Int           @default(0) @db.SmallInt
  unranked_defeats         Int           @default(0) @db.SmallInt
  swiftplay_defeats        Int           @default(0) @db.SmallInt
  ranked_swiftplay_defeats Int           @default(0) @db.SmallInt
  arena_metadata           Json?
  daily_time               DateTime?
  claim_time               DateTime?
  warn                     Boolean       @default(false)
  pity                     Int           @default(0) @db.SmallInt
  claims                   Int           @default(0)
  fates                    Int           @default(0) @db.SmallInt
  rank_rating              Int           @default(0)
  remind                   Boolean?
  remind_in                String?
  reminded                 Boolean       @default(true)
  transactions             Transaction[]
  career                   Match[]
  trade_time               DateTime?
  warned                   Boolean?
  iron_packs               Int           @default(0)
  bronze_packs             Int           @default(0)
  silver_packs             Int           @default(0)
  gold_packs               Int           @default(0)
  platinum_packs           Int           @default(0)
  diamond_packs            Int           @default(0)
  ascendant_packs          Int           @default(0)
  immortal_packs           Int           @default(0)
  radiant_packs            Int           @default(0)
  last_vote                DateTime?
  vote_streak              Int           @default(0)

  @@index([coins, correct_predictions, rank_rating, arena_wins])
}

model Match {
  id       BigInt       @id @default(autoincrement())
  user     User         @relation(fields: [userId], references: [id])
  userId   String
  mode     MatchMode
  winner   Boolean
  teams    CareerTeam[]
  points   Int?         @db.SmallInt
  metadata Json?
  when     DateTime     @default(now())

  @@index([userId])
}

model CareerTeam {
  id      String @id @default(uuid())
  match   Match  @relation(fields: [matchId], references: [id])
  matchId BigInt
  user    String
  score   Int    @db.SmallInt

  @@index([matchId])
}

model Transaction {
  id         String          @id @default(uuid())
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  type       TransactionType
  player     Int?            @db.SmallInt
  pack       Pack?
  price      BigInt?
  to         String?
  created_at DateTime        @default(now())

  @@index([userId, type])
}

model Premium {
  id         String      @id @default(uuid())
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String      @unique
  type       PremiumType
  expires_at DateTime

  @@index([userId])
}

model Prediction {
  id         String           @id @default(uuid())
  user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  match      String
  game       Game
  teams      Team[]
  status     PredictionStatus @default(pending)
  bet        BigInt?
  odd        Int?             @db.SmallInt
  created_at DateTime         @default(now())

  @@index([userId, game, id, match])
}

model Team {
  id           String     @id @default(uuid())
  prediction   Prediction @relation(fields: [predictionId], references: [id], onDelete: Cascade)
  predictionId String
  name         String
  score        String
  winner       Boolean?

  @@index([predictionId])
}

model Guild {
  id                         String        @id
  lang                       Language      @default(en)
  events                     Event[]
  valorant_resend_time       DateTime?
  valorant_matches           String[]      @default([])
  valorant_news_channel      String?
  valorant_live_feed_channel String?
  lol_resend_time            DateTime?
  lol_matches                String[]      @default([])
  lol_news_channel           String?
  lol_live_feed_channel      String?
  tbd_matches                TBDMatch[]
  key                        GuildKey?
  tournaments_length         Int           @default(5) @db.SmallInt
  partner                    Boolean?
  invite                     String?
  live_messages              LiveMessage[]
  guildKeyId                 String?
}

model LiveMessage {
  id      String @id @default(uuid())
  guild   Guild  @relation(fields: [guildId], references: [id], onDelete: Cascade)
  guildId String
  message String
  event   String

  @@index([guildId])
}

model GuildKey {
  id      String @id @default(uuid())
  guild   Guild  @relation(fields: [guildId], references: [id], onDelete: Cascade)
  guildId String @unique
  key     Key    @relation(fields: [keyId], references: [id], onDelete: Cascade)
  keyId   String

  @@unique([guildId, keyId])
  @@index([guildId, keyId])
}

model Key {
  id         String     @id @default(uuid())
  type       KeyType
  expires_at DateTime?
  user       String
  active     Boolean    @default(false)
  active_in  String[]   @default([])
  guildKeys  GuildKey[]

  @@index([user, type])
}

model TBDMatch {
  id      String    @id @default(uuid())
  guild   Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)
  guildId String
  matchId String
  type    EventType
  channel String

  @@index([guildId])
}

model Event {
  id       String    @id @default(uuid())
  guild    Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)
  guildId  String
  type     EventType
  name     String
  channel1 String
  channel2 String

  @@index([guildId, type])
}

model Update {
  id           String    @id
  published_at DateTime  @default(now())
  content      Content[]
}

model Content {
  id       String @id @default(uuid())
  update   Update @relation(fields: [updateId], references: [id])
  updateId String
  lang     String
  text     String

  @@index([updateId])
}

model Blacklist {
  id      String        @id
  type    BlacklistType
  name    String?
  when    DateTime      @default(now())
  reason  String
  ends_at DateTime?

  @@index([type])
}

enum Pack {
  IRON
  BRONZE
  SILVER
  GOLD
  PLATINUM
  DIAMOND
  ASCENDANT
  IMMORTAL
  RADIANT
}

enum BlacklistType {
  USER
  GUILD
}

enum KeyType {
  BOOSTER
  PREMIUM
}

enum EventType {
  valorant
  lol
}

enum MatchMode {
  RANKED
  UNRANKED
  RANKED_SWIFTPLAY
  SWIFTPLAY
  TOURNAMENT
  ARENA
}

enum TransactionType {
  CLAIM_PLAYER_BY_CLAIM_COMMAND
  CLAIM_PLAYER_BY_COMMAND
  SELL_PLAYER
  TRADE_PLAYER
  SIGN_PLAYER
  CLAIM_PACK_BY_VOTE
  CLAIM_PLAYER_BY_PACK
}

enum PremiumType {
  PREMIUM
}

enum Language {
  pt
  en
}

enum Game {
  valorant
  lol
}

enum PredictionStatus {
  correct
  pending
  wrong
}
